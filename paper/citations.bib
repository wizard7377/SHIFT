@inproceedings{10.1007/10705424_6,
  title = {A Functional-Logic Perspective of Parsing},
  booktitle = {Functional and Logic Programming},
  author = {Caballero, Rafael and López-Fraguas, Francisco J.},
  editor = {Middeldorp, Aart and Sato, Taisuke},
  date = {1999},
  pages = {85--99},
  publisher = {Springer Berlin Heidelberg},
  location = {Berlin, Heidelberg},
  abstract = {Parsing has been a traditional workbench for showing the virtues of declarative programming. Both logic and functional programming claim the ability of writing parsers in a natural and concise way. We address here the task from a functional-logic perspective. By modelling parsers as non-deterministic functions we achieve a very natural manner of building parsers, which combines the nicest properties of the functional and logic approaches. In particular, we are able to define parsers within our framework in a style very close to that of functional programming parsers, but using simpler concepts. Moreover, we have moved beyond usual declarative approaches to parsers, since the functional-logic parsers presented here can be considered as truly data values. As an example of this feature we define a function that detects ambiguous grammars.},
  isbn = {978-3-540-47950-5}
}

@inproceedings{10.3115/991719.991764,
  title = {A Uniform Architecture for Parsing and Generation},
  booktitle = {Proceedings of the 12th Conference on Computational Linguistics - Volume 2},
  author = {Shieber, Stuart M.},
  date = {1988},
  series = {Coling '88},
  pages = {614--619},
  publisher = {Association for Computational Linguistics},
  location = {USA},
  doi = {10.3115/991719.991764},
  url = {https://doi.org/10.3115/991719.991764},
  abstract = {The use of a single grammar for both parsing and generation is an idea with a certain elegance, the desirability of which several researchers have noted. In this paper, we discuss a more radical possibility: not only can a single grammar be used by different processes engaged in various "directions" of processing, but one and the same language-processing architecture can be used for processing the grammar in the various modes. In particular, parsing and generation can be viewed as two processes engaged in by a single parameterized theorem prover for the logical interpretation of the formalism. We discuss our current implementation of such an architecture, which is parameterized in such a way that it can be used for either purpose with grammars written in the PATR formalism. Furthermore, the architecture allows fine tuning to reflect different processing strategies, including parsing models intended to mimic psycholinguistic phenomena. This tuning allows the parsing system to operate within the same realm of efficiency as previous architectures for parsing alone, but with much greater flexibility for engaging in other processing regimes.},
  isbn = {963 8431 56 3},
  pagetotal = {6}
}

@article{adaptivellparsingparretal2014,
  title = {Adaptive {{LL}}(*) Parsing: The Power of Dynamic Analysis},
  author = {Parr, Terence and Harwell, Sam and Fisher, Kathleen},
  date = {2014-10},
  journaltitle = {SIGPLAN Not.},
  volume = {49},
  number = {10},
  pages = {579--598},
  publisher = {Association for Computing Machinery},
  location = {New York, NY, USA},
  issn = {0362-1340},
  doi = {10.1145/2714064.2660202},
  url = {https://doi.org/10.1145/2714064.2660202},
  abstract = {This paper introduces the ALL(*) parsing strategy that combines the simplicity, efficiency, and predictability of conventional top-down LL(k) parsers with the power of a GLR-like mechanism to make parsing decisions.},
  issue_date = {October 2014},
  pagetotal = {20},
  keywords = {all(*),augmented transition networks,dfa,gll,glr,grammar,ll(*),nondeterministic parsing,peg}
}

@software{Agda_Developers_Agda,
  title = {Agda},
  author = {{Agda Developers}},
  url = {https://agda.readthedocs.io/},
  version = {2.8.0}
}

@misc{Coq-refman,
  title = {The {{Coq}} Reference Manual – Release 8.19.0},
  author = {{The Coq Development Team}},
  date = {2024},
  url = {https://coq.inria.fr/doc/V8.19.0/refman}
}

@incollection{covar,
  title = {Subtyping and {{Variance}}},
  shorttitle = {Covar},
  booktitle = {The {{Rustonomicon}}},
  url = {https://doc.rust-lang.org/nomicon/subtyping.html},
  urldate = {2025-01-26},
  langid = {english},
  keywords = {reading},
  file = {/home/asherf/Zotero/storage/2BNJ7XSZ/subtyping.html}
}

@article{cumulativehigherorderlogicdegenjohannsen2000,
  title = {Cumulative {{Higher-Order Logic}} as a {{Foundation}} for {{Set Theory}}},
  author = {Degen, Wolfgang and Johannsen, Jan},
  date = {2000-05},
  journaltitle = {MLQ},
  shortjournal = {MLQ - Math. Log. Quart.},
  volume = {46},
  number = {2},
  pages = {147--170},
  issn = {09425616, 15213870},
  doi = {10.1002/(SICI)1521-3870(200005)46:2<147::AID-MALQ147>3.0.CO;2-2},
  url = {https://onlinelibrary.wiley.com/doi/10.1002/(SICI)1521-3870(200005)46:2<147::AID-MALQ147>3.0.CO;2-2},
  urldate = {2025-01-31}
}

@misc{eleftheriadis2021cumulativehierarchyhomotopytype,
  title = {The Cumulative Hierarchy in Homotopy Type Theory},
  author = {Eleftheriadis, Ioannis},
  date = {2021},
  eprint = {2108.06348},
  eprinttype = {arXiv},
  eprintclass = {math.LO},
  url = {https://arxiv.org/abs/2108.06348}
}

@inproceedings{elkhoundfastpracticalmcpeaknecula2004,
  title = {Elkhound: A Fast, Practical {{GLR}} Parser Generator},
  booktitle = {Compiler Construction},
  author = {McPeak, Scott and Necula, George C.},
  editor = {Duesterwald, Evelyn},
  date = {2004},
  pages = {73--88},
  publisher = {Springer Berlin Heidelberg},
  location = {Berlin, Heidelberg},
  abstract = {The Generalized LR (GLR) parsing algorithm is attractive for use in parsing programming languages because it is asymptotically efficient for typical grammars, and can parse with any context-free grammar, including ambiguous grammars. However, adoption of GLR has been slowed by high constant-factor overheads and the lack of a general, user-defined action interface.},
  isbn = {978-3-540-24723-4}
}

@book{flach2022simply,
  title = {Simply {{Logical}} – {{Intelligent Reasoning}} by {{Example}} ({{Fully Interactive Online Edition}})},
  author = {Flach, Peter and Sokol, Kacper},
  date = {2022},
  doi = {10.5281/zenodo.1156977},
  url = {https://book.simply-logical.space/}
}

@article{gllparse,
  title = {{{GLL Parsing}}},
  author = {Scott, Elizabeth and Johnstone, Adrian},
  date = {2010-09},
  journaltitle = {Electronic Notes in Theoretical Computer Science},
  shortjournal = {Electronic Notes in Theoretical Computer Science},
  volume = {253},
  number = {7},
  pages = {177--189},
  issn = {15710661},
  doi = {10.1016/j.entcs.2010.08.041},
  url = {https://linkinghub.elsevier.com/retrieve/pii/S1571066110001209},
  urldate = {2025-01-30},
  langid = {english}
}

@inproceedings{glrtomita,
  title = {{{LR}} Parsers for Natural Languages},
  booktitle = {Proceedings of the 10th International Conference on Computational Linguistics and 22nd Annual Meeting on Association for Computational Linguistics},
  author = {Tomita, Masaru},
  date = {1984},
  series = {Acl '84/Coling '84},
  pages = {354--357},
  publisher = {Association for Computational Linguistics},
  location = {USA},
  doi = {10.3115/980491.980564},
  url = {https://doi.org/10.3115/980491.980564},
  abstract = {MLR, an extended LR parser, is introduced, and its application to natural language parsing is discussed. An LR parser is a shift-reduce parser which is deterministically guided by a parsing table. A parsing table can be obtained automatically from a context-free phrase structure grammar. LR parsers cannot manage ambiguous grammars such as natural language grammars, because their parsing tables would have multiply-defined entries, which precludes deterministic parsing. MLR, however, can handle multiply-defined entries, using a dynamic programming method. When an input sentence is ambiguous, the MLR parser produces all possible parse trees without parsing any part of the input sentence more than once in the same way, despite the fact that the parser does not maintain a chart as in chart parsing. Our method also provides an elegant solution to the problem of multi-part-of-speech words such as "that". The MLR parser and its parsing table generator have been implemented at Carnegie-Mellon University.},
  pagetotal = {4}
}

@book{hottbook,
  title = {Homotopy Type Theory: {{Univalent}} Foundations of Mathematics},
  shorttitle = {{{HoTT}}},
  author = {Univalent Foundations Program, The},
  date = {2013},
  location = {Institute for Advanced Study},
  langid = {english}
}

@inproceedings{lavie-tomita-1993-glr,
  title = {{{GLR}}* – an Efficient Noise-Skipping Parsing Algorithm for Context Free Grammars},
  booktitle = {Proceedings of the Third International Workshop on Parsing Technologies},
  author = {Lavie, Alon and Tomita, Masaru},
  editor = {Bunt, Harry and Berwick, Robert and Church, Ken and Joshi, Aravind and Kaplan, Ronald and Kay, Martin and Lang, Bernard and Nagao, Makoto and Nijholt, Anton and Steedman, Mark and Thompson, Henry and Tomita, Masaru and Vijay-Shanker, K. and Wilks, Yorick and Wittenburg, Kent},
  year = {08 10-13 1993},
  pages = {123--134},
  publisher = {Association for Computational Linguistics},
  location = {Tilburg, Netherlands and Durbuy, Belgium},
  url = {https://aclanthology.org/1993.iwpt-1.12/},
  abstract = {This paper describes GLR*, a parser that can parse any input sentence by ignoring unrecognizable parts of the sentence. In case the standard parsing procedure fails to parse an input sentence, the parser nondeterministically skips some word(s) in the sentence, and returns the parse with fewest skipped words. Therefore, the parser will return some parse(s) with any input sentence, unless no part of the sentence can be recognized at all. The problem can be defined in the following way: Given a context-free grammar G and a sentence S, find and parse S' – the largest subset of words of S, such that S'∈L(G). The algorithm described in this paper is a modification of the Generalized LR (Tomita) parsing algorithm [Tomita, 1986] . The parser accommodates the skipping of words by allowing shift operations to be performed from inactive state nodes of the Graph Structured Stack. A heuristic similar to beam search makes the algorithm computationally tractable. There have been several other approaches to the problem of robust parsing, most of which are special purpose algorithms [Carbonell and Hayes, 1984] , [Ward, 1991] and others. Because our approach is a modification to a standard context-free parsing algorithm, all the techniques and grammars developed for the standard parser can be applied as they are. Also, in case the input sentence is by itself grammatical, our parser behaves exactly as the standard GLR parser. The modified parser, GLR*, has been implemented and integrated with the latest version of the Generalized LR Parser/Compiler [Tomita et al , 1988], [Tomita, 1990]. We discuss an application of the GLR* parser to spontaneous speech understanding and present some preliminary tests on the utility of the GLR* parser in such settings.}
}

@book{learnprolognow,
  title = {Learn Prolog Now!},
  author = {Blackburn, Patrick and Bos, Johan and Striegnitz, Kristina},
  date = {2006},
  series = {Texts in Computing},
  volume = {7},
  publisher = {College Publications},
  isbn = {1-904987-17-6}
}

@book{lof,
  title = {Programming in {{Martin-Löf}}'s Type Theory},
  author = {Nordsrtöm, Bengt and Petersson, Kent and Smith, Jan},
  date = {1990-01},
  url = {https://www.cse.chalmers.se/research/group/logic/book/book.pdf},
  urldate = {2025-01-26}
}

@online{LPrologHomePage,
  title = {{{λProlog Home Page}}},
  url = {https://www.lix.polytechnique.fr/Labo/Dale.Miller/lProlog/},
  urldate = {2025-01-29},
  file = {/home/asherf/Zotero/storage/W3AX8HX4/lProlog.html}
}

@book{metamath,
  title = {Metamath: A Computer Language for Mathematical Proofs},
  shorttitle = {Metamath},
  author = {Megill, Norman D.},
  date = {2019},
  publisher = {Lulu Press},
  location = {Morrisville, North Carolina},
  author+duplicate-1 = {David A. Wheeler}
}

@misc{Parserstimeline,
  title = {Parsers Timeline},
  url = {https://parsing.stereobooster.com/parsers-timeline/}
}

@article{ProofgraphsMinimalImplicationalQuispe-CruzEtAl2014,
  title = {Proof-Graphs for {{Minimal Implicational Logic}}},
  author = {Quispe-Cruz, Marcela and Haeusler, Edward Hermann and Gordeev, Lew},
  date = {2014-03-30},
  journaltitle = {Electronic Proceedings in Theoretical Computer Science},
  shortjournal = {Electron. Proc. Theor. Comput. Sci.},
  volume = {144},
  pages = {16--29},
  issn = {2075-2180},
  doi = {10.4204/EPTCS.144.2},
  url = {http://arxiv.org/abs/1404.0082v1},
  urldate = {2025-01-30},
  langid = {english},
  file = {/home/asherf/Zotero/storage/DEDDTFRV/Quispe-Cruz et al. - 2014 - Proof-graphs for Minimal Implicational Logic.pdf}
}

@article{PropositionsTypesWadler,
  title = {Propositions as {{Types}}},
  author = {Wadler, Philip},
  url = {https://homepages.inf.ed.ac.uk/wadler/papers/propositions-as-types/propositions-as-types.pdf}
}

@article{purelyfunctionalgllvanbinsbergenetal2020,
  title = {Purely Functional {{GLL}} Parsing},
  author = {family=Binsbergen, given=L. Thomas, prefix=van, useprefix=true and Scott, Elizabeth and Johnstone, Adrian},
  date = {2020},
  journaltitle = {Journal of Computer Languages},
  volume = {58},
  pages = {100945},
  issn = {2590-1184},
  doi = {10.1016/j.cola.2020.100945},
  url = {https://www.sciencedirect.com/science/article/pii/S2590118420300058},
  abstract = {Generalised parsing has become increasingly important in the context of software language design and several compiler generators and language workbenches have adopted generalised parsing algorithms such as GLR and GLL. The original GLL parsing algorithms are described in low-level pseudo-code as the output of a parser generator. This paper explains GLL parsing differently, defining the FUN-GLL algorithm as a collection of pure, mathematical functions and focussing on the logic of the algorithm by omitting implementation details. In particular, the data structures are modelled by abstract sets and relations rather than specialised implementations. The description is further simplified by omitting lookahead and adopting the binary subtree representation of derivations to avoid the clerical overhead of graph construction. Conventional parser combinators inherit the drawbacks from the recursive descent algorithms they implement. Based on FUN-GLL, this paper defines generalised parser combinators that overcome these problems. The algorithm is described in the same notation and style as FUN-GLL and uses the same data structures. Both algorithms are explained as a generalisation of basic recursive descent algorithms. The generalised parser combinators of this paper have several advantages over combinator libraries that generate internal grammars. For example, with the generalised parser combinators it is possible to parse larger permutation phrases and to write parsers for languages that are not context-free. The ‘BNF combinator library’ is built around the generalised parser combinators. With the library, embedded and executable syntax specifications are written. The specifications contain semantic actions for interpreting programs and constructing syntax trees. The library takes advantage of Haskell’s type-system to type-check semantic actions and Haskell’s abstraction mechanism enables ‘reuse through abstraction’. The practicality of the library is demonstrated by running parsers obtained from the syntax descriptions of several software languages.},
  keywords = {Functional programming,Generalised parsing,Parser combinators,Syntax descriptions,Top-down parsing}
}

@inproceedings{quantitative-type-theory,
  title = {The Syntax and Semantics of Quantitative Type Theory},
  booktitle = {{{LICS}} '18: 33rd Annual {{ACM}}/{{IEEE}} Symposium on Logic in Computer Science, July 9–12, 2018, Oxford, United Kingdom},
  author = {Atkey, Robert},
  date = {2018},
  pages = {56--65},
  publisher = {Association for Computing Machinery},
  doi = {10.1145/3209108.3209189}
}

@book{Rustonomicon,
  title = {The {{Rustonomicon}}},
  url = {https://doc.rust-lang.org/nomicon/subtyping.html},
  urldate = {2025-01-26},
  langid = {english},
  keywords = {reading}
}

@article{securedistributedprogrammingswamyetal2011,
  title = {Secure Distributed Programming with Value-Dependent Types},
  author = {Swamy, Nikhil and Chen, Juan and Fournet, Cédric and Strub, Pierre-Yves and Bhargavan, Karthikeyan and Yang, Jean},
  date = {2011-09},
  journaltitle = {SIGPLAN Not.},
  volume = {46},
  number = {9},
  pages = {266--278},
  publisher = {Association for Computing Machinery},
  location = {New York, NY, USA},
  issn = {0362-1340},
  doi = {10.1145/2034574.2034811},
  url = {https://doi.org/10.1145/2034574.2034811},
  abstract = {We present F*, a full-fledged design and implementation of a new dependently typed language for secure distributed programming.},
  issue_date = {September 2011},
  pagetotal = {13},
  keywords = {refinement types,security types}
}

@article{SHIEBER19953,
  title = {Principles and Implementation of Deductive Parsing},
  author = {Shieber, Stuart M. and Schabes, Yves and Pereira, Fernando C.N.},
  date = {1995},
  journaltitle = {The Journal of Logic Programming},
  volume = {24},
  number = {1},
  pages = {3--36},
  issn = {0743-1066},
  doi = {10.1016/0743-1066(95)00035-i},
  url = {https://www.sciencedirect.com/science/article/pii/074310669500035I},
  abstract = {We present a system for generating parsers based directly on the metaphor of parsing as deduction. Parsing algorithms can be represented directly as deduction systems, and a single deduction engine can interpret such deduction systems so as to implement the corresponding parser. The method generalizes easily to parsers for augmented phrase structure formalisms, such as definite-clause grammars and other logic grammar formalisms, and has been used for rapid prototyping of parsing algorithms for a variety of formalisms including variants of tree-adjoining grammars, categorial grammars, and lexicalized context-free grammars.}
}

@misc{smtlib,
  title = {The {{Satisfiability Modulo Theories Library}} ({{SMT-LIB}})},
  author = {Barrett, Clark and Fontaine, Pascal and Tinelli, Cesare},
  date = {2016},
  keywords = {cite,reading},
  annotation = {Published: \textbackslash tt www.SMT-LIB.org}
}

@article{swipl,
  title = {{{SWI-prolog}}},
  author = {Wielemaker, Jan and Schrijvers, Tom and Triska, Markus and Lager, Torbjörn},
  date = {2012},
  journaltitle = {Theory and Practice of Logic Programming},
  volume = {12},
  number = {1--2},
  pages = {67--96},
  issn = {1471-0684},
  doi = {10.1017/S1471068411000494},
  abstract = {SWI-Prolog is neither a commercial Prolog system nor a purely academic enterprise, but increasingly a community project.}
}

@inproceedings{thire:hal-02150179,
  title = {Cumulative Types Systems and Levels},
  booktitle = {{{LFMTP}} 2019 - Logical Frameworks and Meta-Languages: {{Theory}} and Practice},
  author = {Thiré, François},
  date = {2019-06},
  location = {Vancouver, Canada},
  url = {https://hal.science/hal-02150179},
  hal_id = {hal-02150179},
  hal_version = {v1}
}

@misc{wikilamed,
  title = {ל־ — Wiktionary, the Free Dictionary},
  author = {{Wiktionary}},
  date = {2024},
  url = {https://en.wiktionary.org/w/index.php?title=%D7%9C%D6%BE&oldid=83073175}
}

@misc{wikimem,
  title = {מ־ — Wiktionary, the Free Dictionary},
  author = {{Wiktionary}},
  date = {2024},
  url = {https://en.wiktionary.org/w/index.php?title=%D7%9E%D6%BE&oldid=82275353}
}

@misc{wikiyud,
  title = {יי — Wiktionary, the Free Dictionary},
  author = {{Wiktionary}},
  date = {2024},
  url = {https://en.wiktionary.org/w/index.php?title=%D7%99%D7%99&oldid=81778961}
}

@software{z3,
  title = {{{Z3Prover}}/Z3: {{The Z3 Theorem Prover}}},
  shorttitle = {Z3},
  url = {https://github.com/Z3Prover/z3/tree/master},
  urldate = {2025-01-26},
  organization = {Microsoft},
  keywords = {cite},
  file = {/home/asherf/Zotero/storage/K4J9TGBG/master.html}
}

@article{zermelofraenkelsettheorypollock1970,
  title = {{{ZERMELO-FRAENKEL SET THEORY AND CUMULATIVE TYPE THEORY}}},
  author = {Pollock, John L.},
  date = {1970},
  journaltitle = {Logique et Analyse},
  volume = {13},
  number = {52},
  eprint = {44085110},
  eprinttype = {jstor},
  pages = {452--466},
  publisher = {Peeters Publishers},
  issn = {00245836, 22955836},
  url = {http://www.jstor.org/stable/44085110},
  urldate = {2025-01-31}
}
