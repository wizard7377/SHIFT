\section{Covariance, Invariance, and Contravariance}

One important thing to note is that certain types do \emph{vary} alongside their elements.
For instance, if we have the expression, $\nat + \mathbb{Z}$, we would like to say purely because it is both an expression that contains $\mathbb{Z}$ and the fact that $\nat : \mathbb{Z}$ to say that $\nat + \nat$ is a subtype of $\nat + \mathbb{Z}$.

While in this specific instance this fact happens to hold true, this generalized inference about subterms is not allowed, that is, we would need a specific rule $\lamed A \lamed B \lamed C (A : C \tto (A + B) : (C + B))$ in our assumptions.

Why? 

To answer that, let us take a look at functions.
If we think from the perspective of a programmer, then the statement \verb|func : Fn<A> -> B| \footnote{This is in Rust} is something like a statement, where the function is "saying" something along the lines of 'If you give me something of type $A$, I'll give you something of type $B$ back'.

But, if we consider from the functions perspective, it dosen't \emph{need} to only be defined for this.
It could, for example, just be lazy \footnote{In the "personality" (yes the personality of a function) sense, not in the computational sense} and actually be able to take in, for instance, if $A$ is $\nat$ perhaps it can take any $\mathbb{Z}$ and simply chooses to say that it can only take $\nat$.

In a sense, we might say that we could interpret this in two ways \footnote{For anyone aware of the formalities of this, I know this reasoning isn't exactly strictly formal, but I thought it was fun}, that either \verb|func| is a function limited to $\nat$ or it is just being lazy. 
In a sense, we know less about \verb|func| from \verb|func : Fn<Nat> -> T| then from \verb|func : Fn<Int> -> T| \footnote{No, Rust's standard library doesn't provide Nat or Int However, because of how signedness bits work this example would require types that were one bit apart in size, which can't occur (as almost all languages, including Rust, are byte aligned)}.
\todo{Verb text in foot}

But, if you'll notice, this means that $\sint \to T$ is a subtype of $\nat \to T$, even though $\nat : \sint$.
The reason for this is simple, when a function type has a larger input, it is making more promises about valid uses of the function, and therefore, because there are \emph{less} things that promise more, it is seen as a subtype.

So how does this get back to the addition problem? 
Because, if we could replace any instance of a less specific type with a more specific one and get a more specific type, it would stand to reason that $\nat \to T$ is a subtype of $\sint \to T$, which as we've seen is not true.

Specifacally, over it's input, function types input what is known as contravariance, that is, the more specific the input, the less specific the function type and vice versa.
However, just like both parts of the addition type from before, the output type of a function exhibits covariance, that is, the more speific the subterm the more specific the whole term and vice versa. \cite{Rustonomicon}

Something that occurs much more in programming and much less in pure type theory is what's known as invariance, that is, where the type of a term does not depend on a given subterm   