\section{An Overview of Flat Type Theory}

Before looking at \this, it is important to understand Hierarchal Type Theory as well as Prolog's answer set theory.
To start, let us look at how we repersent the statement "for any natural numbers $A$ and $B$, if $A$ is greater then or equal to $B$, then the succesor to $A$ must be greater then or equal to the successor for $B$".
We might write this is a simple logic as $\forall (A : \nat) \forall (B : \nat) (A = B \proves S(A) = S(B))$.

When representing this in Hierarchal Type Theory\footnote{With the name "sgeq"}, we might write it as $\seq :: \fdt{\nat}{A} \fdt{\nat}{B} A \geq B \to S(A) \geq S(B)$, where $\Pi$ denotates dependent function types.
The notion behind this is that if there exists a mapping (namely sgeq) from the statement $A \geq B$ to $S(A) \geq S(B)$, thence we know that if we have a given statement of the form $A \geq B$, because $\seq$ is a complete mapping from $A \geq B$ to $S(A) \geq S(B)$, we will get a valid argument.

However in Prolog, we would instead write it like this: \verb|S(A) >= S(B) :- A >= B, nat(B), nat(A).|
While at first glance these might seem disimilar, if I write the set theoretic equivalent to the type-theoretical version, using $\phi_S$ to mean "the proposition that determines if something is in $S$", then we could instead write it as $\forall A \forall B (S(A) \geq S(B) \leftarrow A \geq B \leftarrow \phi_\nat (B) \leftarrow \phi_\nat (A)) $.

These look incredibly similar!
Keep that in mind as we take a closer look at the types $A \to B$ and $A :: B$.

\subsection{Meta-typing}

One of the most important tactics in Coq is the \verb|apply| tactic\needcite.
What it does is it takes a function that maps a constructed type to the desired type, proving that it exists.
For instnace, with $\seq$ from before, $\apl \seq \ \mathrm{with} \ 1 \geq 0$ would be $S(1) \geq S(0)$.

In general, for every function $f$ on a logical type $A$ giving a logical type $B$, there is a pair of values $(a,b)$ such that $a$ has the type of $A$ and $b$ has the type of $B$\footnote{For dependent types $B(a)$}.
If we wrote that out formally, in would be 

\begin{math}
	\apl :: \fdt{A \to B}{f} \pdt{A}{a} B
\end{math}

This is simple enough.
Now time for the real strangeness to begin: what is the type of $(::)$?

This might seem like a strange question, what is the type of subtyping, but it has a useful answer.
We know from before that when we use $\apl$, we give a specific example of a function type to prove that it exists.
This makes sense: if everything is a type and representation, if something has a specific type, there exists something of that type.

So, for instance, if $f :: A \to B$, and we know $f$ exists, it is valid to assume $A \to B$ has elements, as $f$ is an element.
We might say that a function $R$\footnote{for raise} is a tactic that takes in a certain value $a$ and proves that its type exists.
Formally, $R :: \fdt{A :: B}{\phi} \pdt{A}{a} B$.
This looks remarkably similar to $\apl :: \fdt{A \to B}{f} \pdt{A}{a} B$
