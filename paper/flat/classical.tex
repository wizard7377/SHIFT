\part{Classical Type Theory}
\section{Types and the Curry-Howard Correspondence}
On the surface, types seem largely the same as sets, simply the idea of saying "what something is". 
Indeed, the most important things in set theory is the correspondence between sets and propositions, so, for instance, if the proposition $\phi_A a$ is the same as "$A$ contains $a$".

This is a direct correspondence between sets and propositions, so, for instance, one example of this is how "$x$ is even", "$x$ mod $2$ is $0$", and $\mathbb{E} \ni x$ are all equivalent. While set theory can be thought of the question "what propositions correspond to what sets" type theory can be viewed as asking "what sets (or types) correspond to (what) propositions?".

Often, the first example of asking what propositions map to what groups are that of the proposition $a=b$.
Let's take a look at a slightly more intuitive example, what is the set of all pairs of things that satisify the propositon  $(a,b)$ corresponds to a right triangle with integral sides.
This is more simple, and we can even list out examples of points that have this property, for instance:
\begin{math}
	\{(3,4),(4,3),(5,12),(12,5),...\}
\end{math}
So, essientally, we just have to scale up or proposition on one arguement $\phi_A a$ to two arguemtns $\phi_{A,B} (a,b)$

With this, it becomes clearer that the set that corresponds to $a = b$ is just all the values for which that statement is true, say $(1,1)$ or $(2,2)$. Oftentimes, we write this type as $\textrm{Eq}$, which contains all those pairs 

\subsection{Polymorphism}
Polymorphism (many forms) is an abstraction found in many programming languages. For instance, in Rust, instead of making a \verb|VecInt| datatype, along with a \verb|VecFloat|, and a seperate implementation for each and every other type, we simply say "The definition of this isn't particular to any given type, so I'm going to tell you how to make a \verb|Vec| for a given type \verb|T|, and then I'll let you (the compiler), figure it out".

In a programming language, this allows much time to be saved while keeping the consistency of static type checking (as opposed to the C solution of "use a \verb|void*|"). This is also modeled in type theory, and the way it is modeled is quite nice and really beatiful.

To start, let's go to a seemingly unrelated topic, namely, a function $f$ that doubles it's input. We might say that $f$ takes in a natural number and outputs a natural number.
In mathematics we put this $f : \mathbb{N} \to \mathbb{N}$. This is essientally saying "when I say "f of x" use this definition of f on the natural number x to get another natural number".

Sound familiar? This is the same process as we were describing with template generics in a language like Rust, where, instead of saying, map this \emph{number} to another \emph{number}, we say map this \emph{type} to another \emph{type}. We might represent the function as $\mathrm{Vec} : \ast \to \ast$ (in one of the largest languages based on type theory, Idris, this would be written \verb|Vec : Type -> Type|). The symbol $\ast$ simply means a type, and we'll talk more about it later

\todo{Need a way longer introduction}