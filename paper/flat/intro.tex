\part{Basis and Basics}

\section{Introduction}
Type theory is arguably the most important field of modern mathematics, underlying things as disparate as computing and linguistics.
It is enormously interesting, however, many books on it have equations and explanations that are hard to read.
So, here I hope to (not) add to this and make a simple, quick reference to type theory for those who want to learn it.
Note that this will assume a basic understanding of simple logic and set theory

Perhaps the most important things to understand about \this are its \emph{differences} from classical type theory.
There are many differences, but perhaps they can be summed up as the core difference that classical type theory views implications as morphinism between types, whereas \this instead views implications as rules in some formal language.


\section{Goals of Flat Type Theory}
\label{paradox}
This system might seem like a fool's errand to some.
Indeed, this will use systems that are in direct violation of many paradoxes over the years, including Rusell's paradox, and Girard's paradox.
This mean seem strange to some, and indeed it is fully possible this system is useless and pointless, but I hope to illustrate why I think that solving these problems is not neccasarry for a system for it to be useful.

The main thought behind this all is the following principle: any system that allows for true and false statements and that is undecidable consistent cannot be used to prove any statements either true or false.

Why is this true?
To illustrate this, I've created a simple paradox based off Rusell's paradox.
It works as follows, for some system $\lang$ let us say we have a proof of some statement $S$, which I will call $P_0$.
Since we know that certain statements that can be proven by $\lang$ may be inconsistent, so, in addition to constructing $P_0$, we must also construct a proof that $P_0$ is consistent, which I shall call $P_1$.
From here on we must, to prove $P_n$ not only construct $P_n$ itself but also $P_{n+1}$

While it may seem that we can just define a inducer $I_0 : \pro \to \pro$, such that $I_0 P_n = P_{n+1}$, the inducer \emph{itself} needs to be proven consistent, which it obviously can't do\footnote{Assuming a system of logic where $x \to x$ is not by itself a valid proof of $x$}, and hence we need to define another set of proofs $P^{I_0}_{n}$

We might then try to define another inducer, $I_1$, such that $\Pi_{P_{n+1} : P_n} I_1 (I_0 P_n) = (I_0 P_{n+1})$, and this inducer requires yet another inducer, $I_2$, so on and so forth.

Note that this applies to any statement in any potentially ambiguous logic.
That is to say, if one statement may be inconsistnet, it is impossible to construct a single consistent proof.

\subsection{Pure Constructivism}
Whether or not you agree that the above arguement is well formed, there still seems to be one insurmountable question.
Simply put, how could this solve a problem that is said to apply to any logic that has both true and false statements?

The answer is in the question. 
This only applies to logic where statements can be proven \emph{false}, by simply extending constructivistic principles, and making it so that not only can statements not depend on certain statements being false, they also can't satisfy that dependency.

\section{Preliminaries}
\subsection{Generalized LL and LR Parsing}

\label{parsehelp}

\todo{Not nearly finished}